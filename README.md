# JSprinciple
# JavaScript 包管理器工作原理简介
不久前，Node.js 社区的负责人之一   [ ashley williams ]:https://github.com/xitu/gold-miner 发了一条这样的推特： 
lockfiles = awesome for apps, bad for libs this is not a new thought, i’m confused why’s everyone mad about this  
锁文件 = 棒（对于应用而言），坏（对于库而言），这不是一个新想法，我只是很困惑，为什么所有的人都因为这个很崩溃  

我不是很懂她说的是什么，所以我决定去深入钻研下，学习一些包管理器的工作机制  

这是个对的选择,因为JavaScript管理器这个大组织中出现了一个新成员,叫做Yarn,刚刚出现,就引发了很多讨论. 

所以利用这个机会,也来理解一下Yarn是怎样和npm区分开来的.为什么要这样.  

我在研究这个的时候觉得很有意思,真希望很久以前就这么做了,所以我现在写一篇关于npm和yarn的简单介绍,来分析我学到的一些东西.    

让我们从一些定义开始:  
# 什么是包?  
包是一段可以复用的代码,这段代码可以从全局注册下载到开发者本地环境,每个包可能会,也可能不会依赖于别的包.  
# 什么是包管理?  
简单的说,包管理器就是一段代码,他可以让你管理依赖(你或者他人写的外部代码),你的项目需要这些依赖来正确运行.  
很多包管理器在处理你的项目的一下部分:  


# 项目代码  
项目代码即你的项目中的代码,你需要为它管理不同的依赖,通常来说,所有代码都被放入像Git这样的版本控制系统里.  

# Manifest资源配置文件(Manifest file)  

Manifest资源配置文件指的是你记录你的所有依赖(需要管理的包)的文件.它也保存了你项目的元数据(Metadata).在JavaScript的世界中,这个文件就是你的package.json  


# 依赖代码  
依赖代码指组成你的依赖的代码,在应用的生命周期里,这段代码不应被更改,在它被需要的时候,也应该能被在内存里的项目代码所访问.  

# 锁文件(Lockfile)  
锁文件是由包管理器自动生成的,他包含了重现全部的依赖源码树需要的所有信息,你的项目依赖中的所有信息,以及他们各自的版本.  
现在值得强调的是. Yarn使用了锁文件,而NPM没有.我们会谈到这种差别导致的一些后果.  
既然我已经向你介绍了包管理器这部分,现在讨论依赖本身.
  
  扁平依赖(flat dependencies)VS嵌套依赖(NestedDependencies)  
  
  为了理解扁平依赖和嵌套依赖的区别,让我们试着可视化你的项目中的依赖树.  
  记住你的项目中的依赖也可能依赖于它自己,这些依赖也能回相应的有一些共同的依赖.
  为了让这个更清楚,我们表达为.我们的应用依赖于依赖A.B和C, C依赖于A.
  
  
  更多链接参考https://zhuanlan.zhihu.com/p/24045251
